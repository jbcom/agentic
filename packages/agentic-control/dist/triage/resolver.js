import { existsSync } from 'node:fs';
import { writeFile } from 'node:fs/promises';
import { anthropic } from '@ai-sdk/anthropic';
import { generateText } from 'ai';
import { simpleGit } from 'simple-git';
export class Resolver {
    model = anthropic('claude-sonnet-4-20250514');
    config;
    git;
    constructor(config) {
        this.config = config;
        this.git = simpleGit(config.workingDirectory);
    }
    // ==========================================================================
    // Main Resolution Methods
    // ==========================================================================
    async resolveBlockers(github, triage) {
        const results = [];
        for (const blocker of triage.blockers) {
            if (!blocker.isAutoResolvable) {
                results.push({
                    success: false,
                    action: `Resolve ${blocker.type}`,
                    description: blocker.description,
                    error: 'Blocker requires human intervention',
                    changes: null,
                    commitSha: null,
                });
                continue;
            }
            const result = await this.resolveBlocker(github, triage.prNumber, blocker);
            results.push(result);
        }
        return results;
    }
    async resolveFeedback(github, triage) {
        const results = [];
        const unaddressed = triage.feedback.items.filter((f) => f.status === 'unaddressed');
        for (const feedback of unaddressed) {
            const result = await this.resolveFeedbackItem(github, triage.prNumber, feedback, {
                prTitle: triage.prTitle,
            });
            results.push(result);
        }
        return results;
    }
    // ==========================================================================
    // Blocker Resolution
    // ==========================================================================
    async resolveBlocker(github, prNumber, blocker) {
        switch (blocker.type) {
            case 'ci_failure':
                return this.fixCIFailure(github, prNumber, blocker);
            case 'review_feedback':
                // This is handled by resolveFeedback
                return {
                    success: true,
                    action: 'Resolve review feedback',
                    description: 'Handled by feedback resolver',
                    error: null,
                    changes: null,
                    commitSha: null,
                };
            default:
                return {
                    success: false,
                    action: `Resolve ${blocker.type}`,
                    description: blocker.description,
                    error: `Cannot auto-resolve blocker type: ${blocker.type}`,
                    changes: null,
                    commitSha: null,
                };
        }
    }
    async fixCIFailure(github, prNumber, blocker) {
        try {
            // Get failure details
            const ciUrl = blocker.url;
            if (!ciUrl) {
                return {
                    success: false,
                    action: 'Fix CI failure',
                    description: blocker.description,
                    error: 'No CI URL available to analyze',
                    changes: null,
                    commitSha: null,
                };
            }
            // Use AI to analyze the failure and generate a fix
            const { text: analysis } = await generateText({
                model: this.model,
                prompt: `Analyze this CI failure and suggest a fix.

CI Failure: ${blocker.description}
URL: ${ciUrl}

Based on common CI failure patterns, what is likely wrong and how should it be fixed?
Be specific about which files to change and what changes to make.`,
            });
            // For now, we'll report the analysis rather than auto-applying
            // Full implementation would use bash/textEditor tools to apply fixes
            await github.postComment(prNumber, `## CI Failure Analysis\n\n${analysis}\n\n_Auto-generated by ai-triage_`);
            return {
                success: true,
                action: 'Analyze CI failure',
                description: `Posted analysis for: ${blocker.description}`,
                error: null,
                changes: null,
                commitSha: null,
            };
        }
        catch (error) {
            return {
                success: false,
                action: 'Fix CI failure',
                description: blocker.description,
                error: error instanceof Error ? error.message : String(error),
                changes: null,
                commitSha: null,
            };
        }
    }
    // ==========================================================================
    // Feedback Resolution
    // ==========================================================================
    async resolveFeedbackItem(github, prNumber, feedback, context) {
        try {
            // Check if there's a suggestion block we can apply directly
            if (feedback.suggestedAction && feedback.path) {
                return this.applySuggestion(github, prNumber, feedback);
            }
            // Generate a response (fix or justification)
            const response = await this.generateResponse(feedback, context);
            if (response.type === 'fix' && feedback.path) {
                // Apply the fix to the file
                return this.applyFix(github, prNumber, feedback, response.content);
            }
            else {
                // Post a justification comment
                return this.postJustification(github, prNumber, feedback, response.content);
            }
        }
        catch (error) {
            return {
                success: false,
                action: `Address feedback ${feedback.id}`,
                description: feedback.body.slice(0, 100),
                error: error instanceof Error ? error.message : String(error),
                changes: null,
                commitSha: null,
            };
        }
    }
    async applySuggestion(_github, _prNumber, feedback) {
        if (!feedback.path || !feedback.suggestedAction) {
            return {
                success: false,
                action: 'Apply suggestion',
                description: 'Missing path or suggestion',
                error: 'Cannot apply suggestion without file path and content',
                changes: null,
                commitSha: null,
            };
        }
        const filePath = `${this.config.workingDirectory}/${feedback.path}`;
        if (!existsSync(filePath)) {
            return {
                success: false,
                action: 'Apply suggestion',
                description: `File not found: ${feedback.path}`,
                error: 'Target file does not exist',
                changes: null,
                commitSha: null,
            };
        }
        if (this.config.dryRun) {
            return {
                success: true,
                action: 'Apply suggestion (dry run)',
                description: `Would apply suggestion to ${feedback.path}`,
                error: null,
                changes: [{ file: feedback.path, type: 'modified' }],
                commitSha: null,
            };
        }
        // Read file, apply suggestion, write back
        // This is simplified - full implementation would handle line-specific changes
        // Apply the suggestion by replacing the file content with the suggestedAction
        const newContent = feedback.suggestedAction;
        await writeFile(filePath, newContent, 'utf-8');
        return {
            success: true,
            action: 'Apply suggestion',
            description: `Applied suggestion to ${feedback.path}`,
            error: null,
            changes: [{ file: feedback.path, type: 'modified' }],
            commitSha: null,
        };
    }
    async generateResponse(feedback, context) {
        const { text } = await generateText({
            model: this.model,
            prompt: `Determine how to respond to this PR feedback.

PR: ${context.prTitle}

Feedback from ${feedback.author} (${feedback.severity} severity):
${feedback.body}

${feedback.path ? `File: ${feedback.path}` : ''}

Should this be fixed or justified? If fixed, what's the fix? If justified, what's the reasoning?

Respond in this format:
TYPE: fix OR justification
CONTENT: <the fix code or justification text>`,
        });
        const typeMatch = text.match(/TYPE:\s*(fix|justification)/i);
        const contentMatch = text.match(/CONTENT:\s*([\s\S]+)/i);
        return {
            type: typeMatch?.[1]?.toLowerCase() ?? 'justification',
            content: contentMatch?.[1]?.trim() ?? text,
        };
    }
    async applyFix(github, prNumber, feedback, fix) {
        if (!feedback.path) {
            return {
                success: false,
                action: 'Apply fix',
                description: 'No file path for fix',
                error: 'Cannot apply fix without target file',
                changes: null,
                commitSha: null,
            };
        }
        if (this.config.dryRun) {
            return {
                success: true,
                action: 'Apply fix (dry run)',
                description: `Would apply fix to ${feedback.path}`,
                error: null,
                changes: [{ file: feedback.path, type: 'modified' }],
                commitSha: null,
            };
        }
        // Apply the fix - post as comment for human review
        try {
            // For now, post the fix as a comment for human review
            await github.postComment(prNumber, `## Suggested Fix for ${feedback.path}\n\n\`\`\`\n${fix}\n\`\`\`\n\n_Responding to feedback from ${feedback.author}_`);
            return {
                success: true,
                action: 'Suggest fix',
                description: `Posted fix suggestion for ${feedback.path}`,
                error: null,
                changes: null,
                commitSha: null,
            };
        }
        catch (error) {
            return {
                success: false,
                action: 'Apply fix',
                description: `Failed to apply fix to ${feedback.path}`,
                error: error instanceof Error ? error.message : String(error),
                changes: null,
                commitSha: null,
            };
        }
    }
    async postJustification(github, prNumber, feedback, justification) {
        try {
            // Extract comment ID if possible
            const commentIdMatch = feedback.id.match(/comment-(\d+)/);
            const commentId = commentIdMatch?.[1];
            if (commentId) {
                await github.replyToComment(prNumber, Number.parseInt(commentId, 10), justification);
            }
            else {
                await github.postComment(prNumber, `Re: ${feedback.author}'s feedback\n\n${justification}`);
            }
            return {
                success: true,
                action: 'Post justification',
                description: `Responded to ${feedback.author}'s feedback`,
                error: null,
                changes: null,
                commitSha: null,
            };
        }
        catch (error) {
            return {
                success: false,
                action: 'Post justification',
                description: `Failed to respond to ${feedback.author}`,
                error: error instanceof Error ? error.message : String(error),
                changes: null,
                commitSha: null,
            };
        }
    }
    // ==========================================================================
    // Git Operations
    // ==========================================================================
    async commitAndPush(message) {
        if (this.config.dryRun) {
            return {
                success: true,
                action: 'Commit and push (dry run)',
                description: `Would commit: ${message}`,
                error: null,
                changes: null,
                commitSha: null,
            };
        }
        try {
            // Use simple-git for safe git operations (no shell injection)
            await this.git.add('-A');
            await this.git.commit(message);
            const commitSha = await this.git.revparse(['HEAD']);
            await this.git.push();
            return {
                success: true,
                action: 'Commit and push',
                description: message,
                error: null,
                changes: null,
                commitSha: commitSha.trim(),
            };
        }
        catch (error) {
            return {
                success: false,
                action: 'Commit and push',
                description: message,
                error: error instanceof Error ? error.message : String(error),
                changes: null,
                commitSha: null,
            };
        }
    }
    /**
     * Get current git status
     */
    async getStatus() {
        const status = await this.git.status();
        return {
            modified: status.modified,
            staged: status.staged,
            untracked: status.not_added,
        };
    }
    /**
     * Get diff for files
     */
    async getDiff(staged = false) {
        if (staged) {
            return this.git.diff(['--cached']);
        }
        return this.git.diff();
    }
}
//# sourceMappingURL=resolver.js.map