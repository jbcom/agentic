/**
 * Intelligent Task Router
 *
 * Routes tasks to optimal agents based on:
 * 1. Sigma-weighted complexity scores
 * 2. Agent capabilities and availability
 * 3. Cost optimization (prefer cheaper agents)
 * 4. Escalation on failure
 */
/**
 * Task Router - intelligently routes tasks to agents
 */
export class TaskRouter {
    config;
    state;
    constructor(config) {
        this.config = {
            maxRetries: 2,
            dailyBudget: 0,
            ...config,
        };
        this.state = {
            dailyCosts: 0,
            lastReset: new Date().toISOString().split('T')[0],
            tasksProcessed: 0,
        };
    }
    /**
     * Route a task to the optimal agent
     */
    async route(task, complexity) {
        this.maybeResetDaily();
        const fullTask = {
            ...task,
            complexityScore: complexity.weighted,
            complexityTier: complexity.tier,
        };
        const trail = [];
        let totalCost = 0;
        // Try each tier from current to expert
        const tierOrder = ['trivial', 'simple', 'moderate', 'complex', 'expert'];
        const startIndex = tierOrder.indexOf(complexity.tier);
        for (let i = startIndex; i < tierOrder.length; i++) {
            const tier = tierOrder[i];
            const agents = this.config.registry.forTier(tier);
            for (const agent of agents) {
                if (!this.canUseAgent(agent, fullTask)) {
                    continue;
                }
                const result = await this.tryAgent(agent, fullTask, trail);
                totalCost += result.totalCost;
                if (result.success && result.agentResult) {
                    this.state.tasksProcessed++;
                    return {
                        success: true,
                        agent: agent.id,
                        result: result.agentResult,
                        totalCost,
                        attempts: trail.length,
                        trail,
                    };
                }
                // If agent failed but next agent in same tier exists, escalate
                const nextAgent = agents[agents.indexOf(agent) + 1];
                if (nextAgent) {
                    this.config.onEscalate?.(agent, nextAgent, 'Agent failed');
                }
            }
        }
        // All agents exhausted
        this.state.tasksProcessed++;
        return {
            success: false,
            agent: 'none',
            result: { success: false, error: 'All agents exhausted', cost: 0 },
            totalCost,
            attempts: trail.length,
            trail,
        };
    }
    /**
     * Check if an agent can be used for a task
     */
    canUseAgent(agent, task) {
        // Check approval requirement
        if (agent.requiresApproval && !this.hasApproval(task, agent)) {
            return false;
        }
        // Check budget
        if (this.config.dailyBudget > 0 && this.state.dailyCosts + agent.cost > this.config.dailyBudget) {
            return false;
        }
        return true;
    }
    /**
     * Try an agent with retries
     */
    async tryAgent(agent, task, trail) {
        let totalCost = 0;
        for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {
            this.config.onAgentSelected?.(agent, task);
            try {
                const result = await agent.execute(task);
                totalCost += result.cost;
                this.state.dailyCosts += result.cost;
                this.config.onCostIncurred?.(agent, result.cost, task);
                trail.push({
                    agent: agent.id,
                    success: result.success,
                    error: result.error,
                });
                if (result.success) {
                    return { success: true, totalCost, agentResult: result };
                }
                // If agent says don't retry, break to next agent
                if (result.escalate || attempt >= this.config.maxRetries) {
                    return { success: false, totalCost, agentResult: result };
                }
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                trail.push({ agent: agent.id, success: false, error: errorMessage });
                if (attempt >= this.config.maxRetries) {
                    return { success: false, totalCost };
                }
            }
        }
        return { success: false, totalCost };
    }
    /**
     * Check if a task has approval for an agent that requires it
     */
    hasApproval(task, agent) {
        // Check metadata for approval flag
        const approved = task.metadata?.approved;
        return approved?.includes(agent.id) ?? false;
    }
    /**
     * Reset daily state if it's a new day
     */
    maybeResetDaily() {
        const today = new Date().toISOString().split('T')[0];
        if (this.state.lastReset !== today) {
            this.state = {
                dailyCosts: 0,
                lastReset: today,
                tasksProcessed: 0,
            };
        }
    }
    /**
     * Get current router state
     */
    getState() {
        return { ...this.state };
    }
    /**
     * Get remaining daily budget
     */
    getRemainingBudget() {
        if (this.config.dailyBudget === 0)
            return Number.POSITIVE_INFINITY;
        return Math.max(0, this.config.dailyBudget - this.state.dailyCosts);
    }
}
/**
 * Create a simple router with default configuration
 */
export function createRouter(registry, options) {
    return new TaskRouter({ registry, ...options });
}
//# sourceMappingURL=router.js.map