/**
 * File Storage
 *
 * Persists queue state to a JSON file on disk.
 * Useful for local testing and single-machine deployments.
 */
import { mkdir, readFile, writeFile } from 'node:fs/promises';
import { dirname } from 'node:path';
/**
 * File-based storage implementation
 */
export class FileStorage {
    filePath;
    constructor(filePath) {
        this.filePath = filePath;
    }
    async read() {
        try {
            const content = await readFile(this.filePath, 'utf-8');
            return JSON.parse(content);
        }
        catch (error) {
            // File doesn't exist, return empty state
            if (error.code === 'ENOENT') {
                return this.createEmptyState();
            }
            throw error;
        }
    }
    async write(state) {
        // Ensure directory exists
        await mkdir(dirname(this.filePath), { recursive: true });
        const updatedState = {
            ...state,
            updatedAt: new Date().toISOString(),
        };
        await writeFile(this.filePath, JSON.stringify(updatedState, null, 2), 'utf-8');
    }
    async acquireLock(holder, ttlMs) {
        const state = await this.read();
        if (state.lock) {
            const expires = new Date(state.lock.expiresAt);
            if (expires > new Date()) {
                return state.lock.holder === holder;
            }
        }
        state.lock = {
            holder,
            acquiredAt: new Date().toISOString(),
            expiresAt: new Date(Date.now() + ttlMs).toISOString(),
        };
        await this.write(state);
        return true;
    }
    async releaseLock(holder) {
        const state = await this.read();
        if (state.lock?.holder === holder) {
            state.lock = null;
            await this.write(state);
        }
    }
    async isLocked() {
        const state = await this.read();
        if (!state.lock)
            return false;
        return new Date(state.lock.expiresAt) > new Date();
    }
    async getLock() {
        const state = await this.read();
        return state.lock;
    }
    createEmptyState() {
        return {
            version: 2,
            updatedAt: new Date().toISOString(),
            lock: null,
            items: [],
            stats: {
                total: 0,
                byStatus: { pending: 0, processing: 0, completed: 0, failed: 0, cancelled: 0 },
                completed24h: 0,
                failed24h: 0,
                avgProcessingTime: 0,
            },
        };
    }
}
//# sourceMappingURL=file.js.map