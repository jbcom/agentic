/**
 * TriageConnectors - Unified API for Issue/Project/Review Management
 *
 * Following the vendor-connectors pattern from the jbcom ecosystem,
 * this class provides cached access to all triage connectors with:
 *
 * 1. Direct TypeScript API - Use connectors directly in your code
 * 2. Vercel AI SDK Tools - Standard tools for AI agents (see tools.ts)
 *
 * Similar to how VendorConnectors provides `get_*_client()` getters,
 * TriageConnectors provides namespaced APIs for issues, projects, and reviews.
 *
 * @example
 * ```typescript
 * import { TriageConnectors } from '@strata/triage';
 *
 * // Initialize once - reads credentials from environment
 * const triage = new TriageConnectors();
 *
 * // Issue operations
 * const issues = await triage.issues.list({ status: 'open' });
 * const issue = await triage.issues.create({ title: 'Fix bug', type: 'bug' });
 * await triage.issues.update('123', { priority: 'high' });
 * await triage.issues.close('123', 'Fixed in PR #456');
 *
 * // Get ready work (no blockers)
 * const ready = await triage.issues.getReadyWork({ limit: 5 });
 *
 * // Statistics
 * const stats = await triage.issues.getStats();
 * ```
 */
import { type ProviderConfig } from '../providers/index.js';
import type { CreateIssueOptions, ListIssuesOptions, ProviderStats, ReadyWork, TriageIssue, TriageProvider, UpdateIssueOptions } from '../providers/types.js';
export interface TriageConnectorsConfig {
    /**
     * Provider configuration. If not provided, will auto-detect.
     * Can be a single config or multiple for different providers.
     */
    provider?: ProviderConfig;
    /**
     * Working directory for local providers (Beads)
     */
    workingDir?: string;
    /**
     * Repository for GitHub provider (owner/repo format)
     */
    repo?: string;
    /**
     * Prefer Beads over GitHub when both are available
     * @default true
     */
    preferBeads?: boolean;
}
/**
 * Unified triage connector providing issue, project, and review APIs.
 *
 * This is the main entry point for programmatic triage operations.
 * For AI agent tools, see `getTriageTools()` in tools.ts.
 */
export declare class TriageConnectors {
    private config;
    private _provider;
    private _initPromise;
    /**
     * Issue operations API
     */
    readonly issues: IssueAPI;
    /**
     * Project operations API (boards, sprints, epics)
     * @remarks Coming soon - currently returns stubs
     */
    readonly projects: ProjectAPI;
    /**
     * Review operations API (PR feedback, comments)
     * @remarks Coming soon - currently returns stubs
     */
    readonly reviews: ReviewAPI;
    constructor(config?: TriageConnectorsConfig);
    /**
     * Get or initialize the underlying provider
     */
    getProvider(): Promise<TriageProvider>;
    /**
     * Reconfigure the connectors with a new configuration.
     * This will reset the underlying provider.
     */
    reconfigure(config: TriageConnectorsConfig): Promise<void>;
    private initializeProvider;
    /**
     * Get the provider name
     */
    getProviderName(): Promise<string>;
    /**
     * Check if the connector is ready
     */
    isReady(): Promise<boolean>;
    /**
     * Sync with remote (for providers that support it)
     */
    sync(): Promise<void>;
}
/**
 * Issue operations API - CRUD and query operations for issues
 */
declare class IssueAPI {
    private connectors;
    constructor(connectors: TriageConnectors);
    /**
     * Create a new issue
     */
    create(options: CreateIssueOptions): Promise<TriageIssue>;
    /**
     * Get an issue by ID
     */
    get(id: string): Promise<TriageIssue | null>;
    /**
     * Update an existing issue
     */
    update(id: string, options: UpdateIssueOptions): Promise<TriageIssue>;
    /**
     * Close an issue
     */
    close(id: string, reason?: string): Promise<TriageIssue>;
    /**
     * Reopen an issue
     */
    reopen(id: string, reason?: string): Promise<TriageIssue>;
    /**
     * Delete an issue (if supported by provider)
     */
    delete(id: string): Promise<void>;
    /**
     * List issues with optional filters
     */
    list(options?: ListIssuesOptions): Promise<TriageIssue[]>;
    /**
     * Search issues by text query
     */
    search(query: string, options?: ListIssuesOptions): Promise<TriageIssue[]>;
    /**
     * Get issues ready to work on (no blockers)
     */
    getReadyWork(options?: {
        limit?: number;
    }): Promise<ReadyWork[]>;
    /**
     * Get blocked issues
     */
    getBlocked(): Promise<TriageIssue[]>;
    /**
     * Add labels to an issue
     */
    addLabels(id: string, labels: string[]): Promise<void>;
    /**
     * Remove labels from an issue
     */
    removeLabels(id: string, labels: string[]): Promise<void>;
    /**
     * Get provider statistics
     */
    getStats(): Promise<ProviderStats>;
}
/**
 * Project operations API - boards, sprints, epics
 *
 * @remarks This API is under development. Currently returns stubs.
 */
declare class ProjectAPI {
    /**
     * List sprints/iterations
     */
    getSprints(): Promise<{
        id: string;
        name: string;
        status: string;
    }[]>;
    /**
     * Get current sprint
     */
    getCurrentSprint(): Promise<{
        id: string;
        name: string;
        status: string;
    } | null>;
    /**
     * Get epics
     */
    getEpics(): Promise<{
        id: string;
        title: string;
        progress: number;
    }[]>;
}
/**
 * Review operations API - PR feedback, comments, approvals
 *
 * @remarks This API is under development. Currently returns stubs.
 */
declare class ReviewAPI {
    /**
     * Get PR review comments
     */
    getPRComments(_prNumber: number): Promise<{
        id: string;
        body: string;
        author: string;
        path?: string;
        line?: number;
    }[]>;
    /**
     * Get unresolved feedback on a PR
     */
    getUnresolvedFeedback(_prNumber: number): Promise<{
        id: string;
        body: string;
        author: string;
        type: 'comment' | 'change_request';
    }[]>;
    /**
     * Reply to a review comment
     */
    replyToComment(_commentId: string, _body: string): Promise<void>;
}
/**
 * Create a TriageConnectors instance with auto-detection
 *
 * @example
 * ```typescript
 * const triage = await createTriageConnectors();
 * const issues = await triage.issues.list({ status: 'open' });
 * ```
 */
export declare function createTriageConnectors(config?: TriageConnectorsConfig): Promise<TriageConnectors>;
export {};
//# sourceMappingURL=connectors.d.ts.map