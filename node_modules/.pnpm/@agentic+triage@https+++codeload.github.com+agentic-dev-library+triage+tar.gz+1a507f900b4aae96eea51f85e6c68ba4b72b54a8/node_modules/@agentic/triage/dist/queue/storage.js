/**
 * Queue Storage Interface
 *
 * Abstract interface for queue persistence.
 * Implementations can use GitHub Issues, Redis, Files, etc.
 */
/**
 * In-memory storage for testing
 */
export class MemoryStorage {
    state;
    constructor(initial) {
        this.state = {
            version: 1,
            updatedAt: new Date().toISOString(),
            lock: null,
            items: [],
            stats: {
                total: 0,
                byStatus: { pending: 0, processing: 0, completed: 0, failed: 0, cancelled: 0 },
                completed24h: 0,
                failed24h: 0,
                avgProcessingTime: 0,
            },
            ...initial,
        };
    }
    async read() {
        return { ...this.state, items: [...this.state.items] };
    }
    async write(state) {
        this.state = { ...state, updatedAt: new Date().toISOString() };
    }
    async acquireLock(holder, ttlMs) {
        if (this.state.lock) {
            const expires = new Date(this.state.lock.expiresAt);
            if (expires > new Date()) {
                return this.state.lock.holder === holder;
            }
        }
        this.state.lock = {
            holder,
            acquiredAt: new Date().toISOString(),
            expiresAt: new Date(Date.now() + ttlMs).toISOString(),
        };
        return true;
    }
    async releaseLock(holder) {
        if (this.state.lock?.holder === holder) {
            this.state.lock = null;
        }
    }
    async isLocked() {
        if (!this.state.lock)
            return false;
        return new Date(this.state.lock.expiresAt) > new Date();
    }
    async getLock() {
        return this.state.lock;
    }
}
//# sourceMappingURL=storage.js.map