/**
 * Intelligent Task Router
 *
 * Routes tasks to optimal agents based on:
 * 1. Sigma-weighted complexity scores
 * 2. Agent capabilities and availability
 * 3. Cost optimization (prefer cheaper agents)
 * 4. Escalation on failure
 */
/**
 * Task Router - intelligently routes tasks to agents
 */
export class TaskRouter {
    config;
    state;
    constructor(config) {
        this.config = {
            maxRetries: 2,
            dailyBudget: 0,
            ...config,
        };
        this.state = {
            dailyCosts: 0,
            lastReset: new Date().toISOString().split('T')[0],
            tasksProcessed: 0,
        };
    }
    /**
     * Route a task to the optimal agent
     */
    async route(task, complexity) {
        this.maybeResetDaily();
        const fullTask = {
            ...task,
            complexityScore: complexity.weighted,
            complexityTier: complexity.tier,
        };
        const trail = [];
        let totalCost = 0;
        let currentTier = complexity.tier;
        // Get all tiers in order of escalation
        const tierOrder = ['trivial', 'simple', 'moderate', 'complex', 'expert'];
        const startIndex = tierOrder.indexOf(currentTier);
        // Try each tier from current to expert
        for (let tierIndex = startIndex; tierIndex < tierOrder.length; tierIndex++) {
            currentTier = tierOrder[tierIndex];
            const agents = this.config.registry.forTier(currentTier);
            for (const agent of agents) {
                // Check approval requirement
                if (agent.requiresApproval && !this.hasApproval(fullTask, agent)) {
                    continue;
                }
                // Check budget
                if (this.config.dailyBudget > 0 && this.state.dailyCosts + agent.cost > this.config.dailyBudget) {
                    continue;
                }
                // Try this agent with retries
                for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {
                    this.config.onAgentSelected?.(agent, fullTask);
                    try {
                        const result = await agent.execute(fullTask);
                        totalCost += result.cost;
                        this.state.dailyCosts += result.cost;
                        this.config.onCostIncurred?.(agent, result.cost, fullTask);
                        trail.push({
                            agent: agent.id,
                            success: result.success,
                            error: result.error,
                        });
                        if (result.success) {
                            this.state.tasksProcessed++;
                            return {
                                success: true,
                                agent: agent.id,
                                result,
                                totalCost,
                                attempts: trail.length,
                                trail,
                            };
                        }
                        // If agent says don't retry, break to next agent
                        if (!result.escalate && attempt < this.config.maxRetries) {
                            continue; // Retry same agent
                        }
                        break; // Move to next agent
                    }
                    catch (error) {
                        trail.push({
                            agent: agent.id,
                            success: false,
                            error: error instanceof Error ? error.message : 'Unknown error',
                        });
                    }
                }
                // Escalate to next agent
                const nextAgent = agents[agents.indexOf(agent) + 1];
                if (nextAgent) {
                    this.config.onEscalate?.(agent, nextAgent, 'Agent failed');
                }
            }
        }
        // All agents exhausted
        this.state.tasksProcessed++;
        return {
            success: false,
            agent: 'none',
            result: {
                success: false,
                error: 'All agents exhausted',
                cost: 0,
            },
            totalCost,
            attempts: trail.length,
            trail,
        };
    }
    /**
     * Check if a task has approval for an agent that requires it
     */
    hasApproval(task, agent) {
        // Check metadata for approval flag
        const approved = task.metadata?.approved;
        return approved?.includes(agent.id) ?? false;
    }
    /**
     * Reset daily state if it's a new day
     */
    maybeResetDaily() {
        const today = new Date().toISOString().split('T')[0];
        if (this.state.lastReset !== today) {
            this.state = {
                dailyCosts: 0,
                lastReset: today,
                tasksProcessed: 0,
            };
        }
    }
    /**
     * Get current router state
     */
    getState() {
        return { ...this.state };
    }
    /**
     * Get remaining daily budget
     */
    getRemainingBudget() {
        if (this.config.dailyBudget === 0)
            return Infinity;
        return Math.max(0, this.config.dailyBudget - this.state.dailyCosts);
    }
}
/**
 * Create a simple router with default configuration
 */
export function createRouter(registry, options) {
    return new TaskRouter({ registry, ...options });
}
//# sourceMappingURL=router.js.map