/**
 * Provider-Agnostic Agent Interfaces
 *
 * This module defines ONLY the interfaces and registry.
 * Actual provider implementations (Ollama, Jules, Cursor, etc.)
 * belong in @agentic/control where users configure their stack.
 *
 * The key insight: developers can use ANY LLM/agent provider
 * by implementing the AgentExecutor interface and registering
 * it with their desired priority and cost weights.
 */
// ============================================================================
// Agent Registry - The Core Primitive
// ============================================================================
/**
 * Registry for managing available agents
 *
 * @example
 * ```typescript
 * const registry = new AgentRegistry();
 *
 * // Register your agents (implementations from @agentic/control or custom)
 * registry.register(myOllamaAgent);
 * registry.register(myJulesAgent);
 * registry.register(myCustomAgent);
 *
 * // Get best agent for a complexity tier
 * const agent = registry.optimalFor('moderate');
 * ```
 */
export class AgentRegistry {
    agents = new Map();
    /**
     * Register an agent
     */
    register(agent) {
        this.agents.set(agent.id, agent);
        return this;
    }
    /**
     * Register multiple agents at once
     */
    registerAll(agents) {
        for (const agent of agents) {
            this.register(agent);
        }
        return this;
    }
    /**
     * Unregister an agent
     */
    unregister(id) {
        return this.agents.delete(id);
    }
    /**
     * Enable/disable an agent at runtime
     */
    setEnabled(id, enabled) {
        const agent = this.agents.get(id);
        if (agent) {
            agent.enabled = enabled;
        }
    }
    /**
     * Update an agent's priority (for dynamic rebalancing)
     */
    setPriority(id, priority) {
        const agent = this.agents.get(id);
        if (agent) {
            agent.priority = priority;
        }
    }
    /**
     * Update an agent's cost (for dynamic pricing)
     */
    setCost(id, cost) {
        const agent = this.agents.get(id);
        if (agent) {
            agent.cost = cost;
        }
    }
    /**
     * Get all registered agents
     */
    all() {
        return Array.from(this.agents.values());
    }
    /**
     * Get all enabled agents
     */
    enabled() {
        return this.all().filter((a) => a.enabled);
    }
    /**
     * Get agents that can handle a specific complexity tier
     * Sorted by priority (lowest first), then by cost
     */
    forTier(tier, includeDisabled = false) {
        return this.all()
            .filter((a) => (includeDisabled || a.enabled) && a.capabilities.tiers.includes(tier))
            .sort((a, b) => {
            // First by priority (lower = better)
            if (a.priority !== b.priority)
                return a.priority - b.priority;
            // Then by cost (lower = better)
            return a.cost - b.cost;
        });
    }
    /**
     * Get the optimal (first choice) agent for a complexity tier
     */
    optimalFor(tier) {
        return this.forTier(tier)[0];
    }
    /**
     * Get agent by ID
     */
    get(id) {
        return this.agents.get(id);
    }
    /**
     * Check if an agent is registered
     */
    has(id) {
        return this.agents.has(id);
    }
    /**
     * Get count of registered agents
     */
    get size() {
        return this.agents.size;
    }
    /**
     * Clear all agents
     */
    clear() {
        this.agents.clear();
    }
    /**
     * Export registry configuration (for serialization)
     */
    export() {
        return this.all().map(({ execute, ...rest }) => rest);
    }
}
//# sourceMappingURL=agents.js.map