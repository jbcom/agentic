/**
 * Escalation State Management
 *
 * Tracks the progression of tasks through the 7-level escalation ladder.
 * Maintains attempt counts, errors, resolution status, and cost tracking.
 */
/**
 * Manager for escalation states across multiple tasks
 */
export class EscalationStateManager {
    states = new Map();
    /**
     * Create or get state for a task
     */
    getState(taskId) {
        if (!this.states.has(taskId)) {
            const now = new Date().toISOString();
            this.states.set(taskId, {
                taskId,
                level: 0,
                attempts: {},
                errors: [],
                resolved: false,
                cost: 0,
                createdAt: now,
                updatedAt: now,
                approved: false,
            });
        }
        const state = this.states.get(taskId);
        if (!state) {
            throw new Error(`Failed to create state for task ${taskId}`);
        }
        return state;
    }
    /**
     * Update state for a task
     */
    updateState(taskId, update) {
        const state = this.getState(taskId);
        const updated = {
            ...state,
            ...update,
            updatedAt: new Date().toISOString(),
        };
        this.states.set(taskId, updated);
        return updated;
    }
    /**
     * Record an attempt at a level
     */
    recordAttempt(taskId, level) {
        const state = this.getState(taskId);
        const levelKey = `level${level}`;
        const attempts = {
            ...state.attempts,
            [levelKey]: (state.attempts[levelKey] || 0) + 1,
        };
        return this.updateState(taskId, { attempts });
    }
    /**
     * Record an error
     */
    recordError(taskId, error) {
        const state = this.getState(taskId);
        const errors = [...state.errors, error];
        return this.updateState(taskId, { errors });
    }
    /**
     * Escalate to next level
     */
    escalate(taskId) {
        const state = this.getState(taskId);
        const newLevel = Math.min(6, state.level + 1);
        return this.updateState(taskId, { level: newLevel });
    }
    /**
     * Mark task as resolved
     */
    resolve(taskId) {
        return this.updateState(taskId, { resolved: true });
    }
    /**
     * Add cost to task
     */
    addCost(taskId, cost) {
        const state = this.getState(taskId);
        return this.updateState(taskId, { cost: state.cost + cost });
    }
    /**
     * Set approval status
     */
    setApproval(taskId, approved) {
        return this.updateState(taskId, { approved });
    }
    /**
     * Reset state for a task
     */
    resetState(taskId) {
        this.states.delete(taskId);
    }
    /**
     * Get all states
     */
    getAllStates() {
        return Array.from(this.states.values());
    }
    /**
     * Get unresolved states
     */
    getUnresolved() {
        return this.getAllStates().filter((s) => !s.resolved);
    }
    /**
     * Clear all states
     */
    clear() {
        this.states.clear();
    }
    /**
     * Get total cost across all tasks
     */
    getTotalCost() {
        return this.getAllStates().reduce((sum, s) => sum + s.cost, 0);
    }
}
//# sourceMappingURL=state.js.map