/**
 * Queue Manager
 *
 * Core queue management logic that works with any storage backend.
 * Handles priority ordering, locking, and state management.
 */
import type { QueueStorage } from './storage.js';
import type { QueueItem, QueueItemStatus, QueueStats } from './types.js';
/**
 * Configuration for the queue manager
 */
export interface QueueManagerConfig {
    /** Lock timeout in milliseconds (default: 5 minutes) */
    lockTimeout?: number;
    /** Maximum retries before marking as failed (default: 3) */
    maxRetries?: number;
    /** Unique identifier for this manager instance */
    instanceId?: string;
}
/**
 * Queue Manager - handles all queue operations
 */
export declare class QueueManager<T extends QueueItem = QueueItem> {
    private storage;
    private config;
    constructor(storage: QueueStorage<T>, config?: QueueManagerConfig);
    /**
     * Add an item to the queue
     */
    add(item: Omit<T, 'status' | 'addedAt' | 'retries'> & Partial<Pick<T, 'status' | 'addedAt' | 'retries'>>): Promise<T>;
    /**
     * Remove an item from the queue
     */
    remove(id: string): Promise<T | undefined>;
    /**
     * Get the next item to process (highest priority, oldest first)
     */
    next(): Promise<T | undefined>;
    /**
     * Get an item by ID
     */
    get(id: string): Promise<T | undefined>;
    /**
     * Update an item's properties
     */
    update(id: string, updates: Partial<Omit<T, 'id'>>): Promise<T | undefined>;
    /**
     * Mark an item as processing
     */
    startProcessing(id: string): Promise<T | undefined>;
    /**
     * Mark an item as completed and remove from queue
     */
    complete(id: string): Promise<T | undefined>;
    /**
     * Mark an item as failed
     * If under max retries, requeue as pending
     */
    fail(id: string, error: string): Promise<T | undefined>;
    /**
     * Cancel an item
     */
    cancel(id: string): Promise<T | undefined>;
    /**
     * List all items (optionally filtered by status)
     */
    list(status?: QueueItemStatus): Promise<T[]>;
    /**
     * Get queue statistics
     */
    stats(): Promise<QueueStats>;
    /**
     * Get current queue length
     */
    length(): Promise<number>;
    /**
     * Clear all items (dangerous!)
     */
    clear(): Promise<void>;
    /**
     * Acquire a lock for processing
     */
    lock(): Promise<boolean>;
    /**
     * Release the lock
     */
    unlock(): Promise<void>;
    /**
     * Check if queue is locked
     */
    isLocked(): Promise<boolean>;
    /**
     * Process the next item with a handler
     * Automatically handles locking, status updates, and error handling
     */
    processNext<R>(handler: (item: T) => Promise<R>): Promise<{
        item: T;
        result: R;
    } | null>;
    /**
     * Sort queue by priority (ascending) then by addedAt (ascending)
     */
    private sortQueue;
    /**
     * Update queue statistics
     */
    private updateStats;
}
//# sourceMappingURL=manager.d.ts.map